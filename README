snaprotate

rotates snapshots

I'd like to force the snap time to be in the filename for the UI property of
exposing that in the filename.

policies that look like:

 keep everything today
 keep one per day for the next week
 keep one per week for the next month
 keep one per month forever

Maybe its useful to force each period to be an integer multiple of the
previous period (so a month becomes 4 weeks, and there are 13 weeks in a year..)

So what do we have:
  directories on disk, each labelled with their time
  configuration file giving above rules - written in haskell?
  persistent store of config data

What does "keep everything today" mean?
  don't delete anything with today's date on it?
  or
  don't delete anything in the last 24h?

Each config line is a level.
When we come to 'delete' a snap in a level, we're actually 'expelling' it.
The expel pushes it to the next level, which might discard it, or might keep
it; and that activity might also discard other things in that level.

We tag each directory with a level when its been assigned to that level.
If its not been tagged, we feed it in to the first level as a new snapshot,
so note that levels (esp at the first invocation) may be fed snaps that are
old, and may be fed them out of order.

So 'keep one per month' == 'keep the earliest in a calendar month that we are
 offered' -- if we are giving one on 5th april and then later given one on
 2nd april, we'll first keep the 5th april one, and then later discard it.
 in favour of the 2nd april one. that won't happen much though - lots at start
 but probably almost never after that.

Level based approach means rules don't need to be multiples of time, or even
use same time windows - eg first rule can be "keep 24h in the past from right
now", but second rule can be based on the actual date in the filename to keep
one per day.  The rules don't even need to strictly nest in time, though
might look a bit weird if they don't. All/most time awareness goes into
level handling code, with wrapper handling the shuffling of snapshots
through levels.

level interface could look like:
   deliver :: Snapshot -> [Snapshot]             -> [Snapshot]
              new snapshot  existing snapshots    the ones to keep

Any existing snapshots that aren't in the ones to keep are then regarded as
expelled, and we deliver to the next level.

What should that look like syntax-wise?
Want to specify a sequence of Level operations, perhaps made using combinators?
   keepAllFromLast (24 * hours)
   keepevery week month  -- keeps one per week for last month

How to sequence? Sequential notation: perhaps, a list of levels.
   filter = [leveldef1, leveldef2, leveldef3, ...]

what about if we change the leveldefs? then we should delete state, and
refilter things from the start. but then, how about if we never have state
and always refilter things from the start? it should be convergent?

regenerating arbitrary requires things to be 'convergent' / 'stable' in
something similar to referential transparency. eg "keep 50%" is not stable
because it will delete 50% of backups every time, although 
"keep 50% based on random number generated by hashing timestamp of dir" would
be stable because keep decision is then not random wrt the input.

What about "keep until disk is full?" or "keep so long as this level occupies
  less than 100Gb" ? That's fine, I think - although the answers will change,
  they're stable in that we can run the same thing over and over (without
  changing the external environment) and we won't change what we delete...
  In that sense, disk space is same as "time now".

If we do this algebraically, and regenerate each time, the levels aren't
explicitly numbered. Instead we have a level combinator --> that will
  feed stuff into the first, everything evicated from the first is fed to the second, and then it will keep everything that either wants to keep, and evict
whatever is left over.

Then if we use list syntax, its a fold of --> over that list.
Or we can use --> syntax directly.

Concrete levels are IO monadic, but --> doesn't need to be? (although would
need to be lifted...)

Other environments rather than specifically deleting:
   'what if?'  - disk use if the rules are changed? (generate a list of directories that would be kept, that we could feed into du)
   disk-usage by rule - needs rule to be human describable - so maybe LevelDef should then have a textual description interface too, rather than being just a function - output that looks like ls but gives a column showing which rule kept a particular directory- so then rule text descr should be 40cols or less...


