snaprotate
Copyright 2010 Ben Clifford benc@hawaga.org.uk

Deletes old rsync snapshots based on filename-encoded dates and
user-specified policy.

REQUIRES:
ghc

BUILDING:
make

There is no installer at the moment - add $(pwd) to your path.

USING:

Snapshot directories should all be in the same parent directory, with
a name like this:
  root-2010-03-28-1205+0000
where root is a user-chosen base name, and the remainer is a date
create by (for example) date +%Y-%m-%d-%H%M%z

Create a policy file like example.snap (there are more details below).
Then, sitting in your snapshot root directory, type:

 $ /path/to/example.snap --base root

This will generate a bunch of debugging info on stderr, and shell commands
on stdout - for each directory, there will either be an rm command to
remove it, or a shell comment giving the reason for keeping it.


OLD NOTES:

When we come to 'delete' a snap in a level, we're actually 'expelling' it.
The expel pushes it to the next level, which might discard it, or might keep
it; and that activity might also discard other things in that level.

So 'keep one per month' == 'keep the earliest in a calendar month that we are
 offered' -- if we are giving one on 5th april and then later given one on
 2nd april, we'll first keep the 5th april one, and then later discard it.
 in favour of the 2nd april one. that won't happen much though - lots at start
 but probably almost never after that.

Level based approach means rules don't need to be multiples of time, or even
use same time windows - eg first rule can be "keep 24h in the past from right
now", but second rule can be based on the actual date in the filename to keep
one per day.  The rules don't even need to strictly nest in time, though
might look a bit weird if they don't. All/most time awareness goes into
level handling code, with wrapper handling the shuffling of snapshots
through levels.

Any existing snapshots that aren't in the ones to keep are then regarded as
expelled, and we deliver to the next level.

regenerating arbitrary requires things to be 'convergent' / 'stable' in
something similar to referential transparency. eg "keep 50%" is not stable
because it will delete 50% of backups every time, although 
"keep 50% based on random number generated by hashing timestamp of dir" would
be stable because keep decision is then not random wrt the input.

What about "keep until disk is full?" or "keep so long as this level occupies
  less than 100Gb" ? That's fine, I think - although the answers will change,
  they're stable in that we can run the same thing over and over (without
  changing the external environment) and we won't change what we delete...
  In that sense, disk space is same as "time now".

Other environments rather than specifically deleting:
   'what if?'  - disk use if the rules are changed? (generate a list of directories that would be kept, that we could feed into du)
   disk-usage by rule - needs rule to be human describable - so maybe LevelDef should then have a textual description interface too, rather than being just a function - output that looks like ls but gives a column showing which rule kept a particular directory- so then rule text descr should be 40cols or less...



feature request:  'keepLastN' - keep the last 3 backups, no matter how old
they are. Usecase: on my laptop, I run backups by hand because of
connectivity of ext HD. and I run snaprotate by hand. But if I don't backup
for a while and then run snaprotate, the most recent backup might pass out of
the 'keep last 48h' level and but not be kept by the 'once per month' or
'once per week' level. This will keep the N most recent backups, no matter
how old they are.

feature request: actually execute rm commands rather than outputting them

todo: idea from dmwit on reddit about using <() instead of explicit temp file
  (runhaskell from ghc 6.10.1 doesn't like FDs coming from <() and wants a
   real file, so maybe this won't work)

